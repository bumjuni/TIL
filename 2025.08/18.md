# 코딩테스트

코딩 테스트 합격자 되기 C++편(박경록) p. 250~289

---

### 문제 16 | 기능 개발

**직관성 vs 효율성**

- 직관성
    - 기존에 짠 코드는 `while`루프를 한 번 돌때마다 하루가 지난다고 가정하여 `days`를 1씩 증가
    - 날짜가 하루 지날 때마다 작업이 일정량 더해지는 것을 직관적으로 이해할 수 있음
    - 그러나 100일이 필요한 작업의 경우 실제로 `while`문을 100번 돌아야 함 ⇒ 효율성 저하( $O(N^2)$)
    - 의사 코드
    
    ```cpp
    1. while문에서 배포할 작업의 개수(deploy)를 초기화
    2. while문에서 경과한 날짜(days)에 따른 현재 작업의 진행도를 계산
    3. 진행도가 100%이상이면 배포
    4. 다음 작업의 진행도도 100% 이상이면 함께 배포
    5. 진행도가 100%미만이면 while문을 종료하고 날짜(days) 증가
    5. 작업 목록의 끝에 도달하면 while문 종료
    ```
    
- 효율성
    - 작업이 끝나는 날짜를 수학적으로 한번에 계산할 수 있음 ⇒ 효율적임($O(N)$)
    - 정답 코드와 GPT 모두 이 방식을 추천
    - 의사 코드
    
    ```cpp
    1. 작업 목록과 작업 속도를 순회하며 필요한 날짜 계산
    2. 계산한 날짜를 순회하며 함께 배포할 수 있는 작업 묶음 계산
    ```
    

**`ceil()`**

- `double`형을 받아 올림한 값을 `double` 로 반환
- `cmath` 헤더에 존재
- `ceil()` 대신 쓸 수 있는 정수 나눗셈 식
    
    나눗셈(a/b)에서 제수(b)보다 적은 수(b-1)를 더함으로써 나머지가 있는 경우 자동으로 1 더한 값이 결과가 됨 
    
    `cmath`헤더를 포함하지 않아도 돼서 빠르고 효율적임
    
    ```cpp
    ceil(a / b) = (a + b - 1) / b
    
    // 따라서 아래 두 식은 같은 결과
    int day = (int)ceil((100.0 - progress[i]) / speeds[i]);
    int day = (100 - progress[i] + speeds[i] - 1) / speeds[i];
    ```
    

### 문제 17 | 카드 뭉치

**예외 처리**

- 문제가 쉽다고 방심할 게 아니라 예외 처리를 잘 해줘야 함..
- goal에는 카드가 남아있는데 각 카드 배열에는 이미 전부 소진한 상태일 수 있음
    
    ⇒ 존재하지 않는 인덱스로 접근하지 않도록 예외 처리 필요
    

## 해시

**정의**

- 순차 탐색하지 않고도 효율적으로 데이터를 저장하고 탐색하기 위해 고안된 자료구조
- 어떻게 빠르게 탐색? → 데이터가 저장되는 위치에 규칙을 부여
- 어떤 규칙? → 해시 함수로 인덱스 생성
- 어떻게 저장? → 키, 값을 해시 함수로 생성된 인덱스로 연결하여 해시 테이블에 저장
- 해시 테이블이란? → 해시 함수와 키를 가지고 만든 인덱스와 그 값을 저장한 테이블. 이때 해시 테이블의 각 데이터를 버킷(bucket)이라고 부름

**특징**

- 해시 함수는 단방향이므로 값을 통해 키를 유추할 수 없음
- 탐색 시간은 O(1)
- 코딩 테스트에서는 데이터 탐색 횟수가 많을 때 해시를 사용하면 좋음

**활용**

- 비밀번호 보안
- 데이터베이스 인덱싱
- 블록체인 무결성 확인

### 해시 함수

- 해시 값은 해시 테이블의 크기를 넘으면 안됨
    
    (= N개의 테이블일 때 해시 값은 0~N-1 사이여야 함)
    
- 충돌이 최대한 적게 발생해야 함

**나눗셈법**

$h(x) = x \; mod \; k$

- k는 소수 (소수가 아닐 시 k를 주기로 충돌이 많이 발생하게 됨)

**곱셈법**

$h(x) = (((x * A)~mod~1) * m)$

- A는 황금비(1.61803…), m은 테이블의 크기
- 키에 황금비를 곱한 후 모듈러 1로 소수 자릿수만 취한 뒤 m을 곱하여 인덱스에 매핑

**문자열 해싱**

$h(s) = (s[0] + s[1]*p + s[2] * p^2 + s[3] * p^3 + \cdot\cdot\cdot  + s[n-1] * p^{n-1})\space mod\space m$

- p는 메르센 소수, s[n]은 문자열의 각 문자를 숫자로 매핑한 것
- 메르센 소수: $2^n-1$의 형태로 표현할 수 있는 소수
    
    (메르센 소수를 사용하면 충돌이 더 적다는 연구 결과가 있음)
    
- 연산 시 숫자가 커질 수 있으므로 모듈러 연산을 통해 숫자를 줄여야 함

$(a + b)~\%~c = (a~\%~c + b~\%~c)$

$\therefore h(s) = (s[0]~\%~m + s[1] * p~\%~m + s[2]*p^2~\%~m + s[3]*p^3~\%~m + \cdot\cdot\cdot + s[n-1] * p^{n-1}~\%~m)~\%~m$

### 충돌 처리

**체이닝**

- 해당 버킷에 링크드리스트로 충돌한 데이터를 연결
- 간단하지만 특정 버킷에 데이터가 몰리면 공간 활용성이 떨어지고, 검색 성능이 떨어짐(O(N))

**개방 주소법**

- 빈 버킷을 찾아 데이터 저장 ⇒ 체이닝보다 효율적인 메모리 활용

**개방 주소법 - 선형 탐사 방식**

$h(k, i) = (h(k) + i)~mod~m$

- 충돌 발생 시 빈 버킷을 찾아 i만큼 이동, m은 테이블 크기
- i = 1이 일반적
- 클러스터 형성 가능성이 있음 ⇒ 충돌 발생 확률 ↑

**개방 주소법 - 이중 해싱 방식**

$h(k, i) = (h_1(k) + i * h_2(k))~mod~m$

- 해시 함수를 두개 사용( $h_1$, $h_2$)
- 첫 번째 해시 함수로 충돌 발생하면 두번째 해시 함수 사용
    
    ⇒ 해당 위치를 기준으로 어떻게 위치를 정할지 결정
    
- 주어진 키 마다 점프하는 위치를 다르게 하여 클러스터 형성 방지

### 문제 18 | 두 개의 수로 특정 값 만들기

**예외 처리**

- 내 풀이가 가능하려면 예외 처리를 매우 꼼꼼하게 해야 함
- `idx`: `target`에서 `arr`의 각 수를 뺀 것
- `idx`가 0보다 큰지 확인 (`arr`의 모든 원소는 1 이상의 자연수)
- `idx`가 `arr`의 원소와 같지 않은지 확인 (`arr`의 원소는 중복x)

**개선사항**

- 배열 크기를 무작정 입력값의 최대인 10000으로 설정
    
    ⇒  `arr`의 원소의 최댓값, 혹은 `target+1` 로 설정
    
- `arr`에 있는 모든 수를 `check`배열에 저장
    
    ⇒ `target`보다 큰 수는 정답이 될 가능성이 없으므로 패스
    

**어려움**

- 해시에 관련된 챕터라서 해시를 떠올리며 풀었지만 그냥 문제를 마주쳤을 때는 어떻게 풀어야 하는지 헤매다가 N^2의 풀이만 떠오를 것 같다….

### 문제 19 | 문자열 해싱을 이용한 검색 함수 만들기

**해시 테이블**

- 반드시 키:값으로 매칭될 필요가 없음
- 인덱스:값, 키: 값으로 매칭되는 vector나 map을 생각했었는데
    
    set으로도 가능함
    
- polynomial hash에서 모듈러 하는 m은 버킷 크기

**개선사항**

- polynomial hash를 반드시 정방향으로 계산하지 않아도 됨
- 역방향으로 계산 시 처음부터 구할 필요는 없음 ( 패턴이 누적됨을 인지하고 기존 값 활용하기)

```cpp
// 내 코드(정방향)
    for (int i = 0; i < str.size(); i++) {
        char c = str[i];
        result += (c * (int)pow(p, i)) % mod;
    }
    
// 개선된 코드(역방향)
		for (char c: str) {
				hash_value = (hash_value * p + c) % m;
		}

```
