# 아두이노

모두의 아두이노(다카모토 다카요리/장진희) p. 125~141

---

## 아날로그 입력

- `int analogRead(pin)`
    - 아날로그 센서 값 입력받기
    - 정숫값 0~1023을 반환 ⇒ 0~5V에 해당
    - 광센서, 온도 센서, 거리 센서, 가변 저항 등
    - 변환식을 통해 반환값을 적절한 단위로 변환할 수 있음

### 가변저항

- 3개의 핀 → GND, 전원(5V), 아날로그 입력 포트(An)
- 극성이 없어서 핀 연결 순서 달라도 됨

**저항값 출력**

- `Serial.println(analogRead(A0));`
    - 가변저항 값을 출력한 것이 아님 (0~1023값)
    - 1023 출력 시 전압 5V를 출력한 것 ⇒ 저항은 0Ω
    - 0 출력 시 전압 0V를 출력한 것 ⇒ 저항은 10kΩ
- `Serial.println((1023 - analogRead(A0)) / 1023.0 * 10000.0);`
    - 변환식을 사용하여 가변저항 값을 출력한 것
    - `1023.0`, `10000.0`을 int로 써버리면 소수점 이하 계산이 안됨
        
        ⇒ 대부분 0으로 출력됨을 주의
        

### 건전지 전압 측정

- 가변저항 측정과 유사하나 GND를 음극, 포트를 양극에 맞춰 잘 연결해야 함
- `long map(value, fromLow, fromHigh, toLow, toHigh)`
    - fromLow ~ fromHigh 에서 toLow ~ toHigh로 비례식에 매핑한 값을 반환해주는 함수
    - 가변저항 변환식: `map(analogRead(A0), 0, 1023, 0, 10000);`
    - 건전지 전압 변환식: `map(analogRead(A0), 0, 1023, 0, 500) / 100.0;`
    - toLow, toHigh의 폭이 너무 좁으면(0~5) 변환값이 항상 정수여서 정확한 수치가 나오지 않음

## 디지털 입력

- `boolean digitalRead(pin)`
    - 디지털 센서 값 입력받기
    - 스위치, 기울기 센서, 초음파 거리 센서, 적외선 리모컨 수신 모듈 등

### 택트 스위치

- 버튼과 4개의 리드선 ⇒ 버튼을 누르면 리드선의 상태 변화

![image.png](attachment:f0757cbf-cf8f-4e0b-b369-0ae73dd427eb:image.png)

- 초록선: ①-③과 ②-④는 항상 연결
- 빨간선: ①-②와 ③-④(혹은 대각선)는 버튼을 눌러야 연결

⇒ ①-②와 ③-④, 또는 ①-④와 ②-③을 사용해야 함

- 빵판에서 한쪽은 GND, 한쪽은 디지털 입력 포트에 연결

### 스위치로 LED 제어하기

- `setup()` 작성

```cpp
void setup() {
	// 택트 스위치를 풀업 저항으로 설정해야 함
	pinMode(2, INPUT_PULLUP);
	// LED를 출력 포트로 설정
	pinMode(13, OUTPUT);
}
```

- 택트 스위치는 풀업 저항에서 눌릴 때 HIGH, 뗄 때 LOW

```cpp
// 스위치가 눌려있으면 LED를 키고, 눌려있지 않으면 LED를 끄는 코드
if (digitalRead(2) == HIGH)  digitalWrite(13, LOW);
else  digitalWrite(13, HIGH);

// 위 코드와 같은 기능
digitalWrite(13, !digitalRead(2));
```

**채터링**

- 택트 스위치를 누르거나 뗄 때 스위치가 떨리면서 미세하게 닿았다 떨어졌다 하는 현상
    
    ⇒ 스케치 코드가 의도대로 동작하지 않을 수 있음
    
    ⇒ `delay()` 등으로 디바운싱을 해야 함
    

```cpp
boolean sw = false; // LED 상태 변수
void loop() {
  while (!chtsw(2)) { // 스위치가 눌리면 실행
	  if (sw) digitalWrite(13, LOW);
	  else  digitalWrite(13, HIGH);  // LED토글
	  sw = !sw;  // LED상태 변경 => 빠르게 점멸하게 됨
	  }
	while (chtsw(2));  // 스위치가 떨어지면 실행(눌릴 때까지 대기)
}

boolean chtsw(byte dx) {
	boolean tsw = digitalRead(dx);
	while (tsw == digitalRead(dx));  // 입력포트의 상태 변할 때까지 대기
	delay(300);  // 채터링을 고려하여 300ms 대기
	return !tsw;
}
```

<aside>
❓

while문에 조건절만 있는 문법은 뭐지..

⇒ empty loop

: 조건절만 있는 while문으로, 조건이 `false`가 될 때까지 busy waiting(다음 코드는 실행되지 X)

위 코드에서는 `while (tsw == digitalRead(dx));`에서 조건이 `false`가 될 때까지 대기하며 `chtsw`에서 멈춰있고, `loop`에 반환값이 전달되지 않은 상황이므로 `loop`도 실행되지 않음

</aside>

### 기울기 센서

= 진동 센서, 경사 스위치, 틸트 스위치

- 직사각 센서 용기 내에 있는 구슬이 단자에 닿아 있다가 진동, 기울기 변화 같은 외부 요인에 의해 구슬이 단자에 떨어지면 전기가 통하지 않음
- 움직임의 속도, 강도가 아닌 움직임의 여부를 감지할 수 있음
- 센서의 짧은 다리끼리, 긴 다리끼리 연결되어 있고,
    
    움직임 발생 시 길이가 다른 두 단자(다리) 간에 전기가 끊김
    

⇒ 풀업 저항의 택트 스위치와 마찬가지로 기본값은 HIGH, 변화 시 LOW

### 기울기 센서 조작하기

```cpp
// 진동을 감지하면 3초 동안 LED를 켜는 스케치
void setup() {
  pinMode(2, INPUT);
  pinMode(13, OUTPUT);
}
void loop() {
  boolean isMoved = digitalRead(2);
  if (isMoved) {
	  digitalWrite(13, true);
    delay(3000);
    digitalWrite(13, false);
  }
}

// 교재 코드
void setup() {
  pinMode(2, INPUT_PULLUP);  // 기울기 센서도 풀업 저항으로 선언해야 함
  pinMode(13, OUTPUT);
}
void loop() {
  boolean sw = false; // 센서의 기본값을 설정해 줘야 함
  while (sw == digitalRead(2));  // 기울기 센서 값이 바뀔 때까지 대기
  digitalWrite(13, LOW);
  delay(3000);
  digitalWrite(13, HIGH);
 }
```

- 기울기 센서 또한 움직임이 있다/없다만을 감지하므로 아날로그가 아님(중간값이 필요 없음)

<aside>
❓

모든 디지털 센서는 풀업 저항을 사용해야 하는건가?

⇒ (GPT) 그렇지는 않음

</aside>

<aside>
❓

교재 코드(empty loop)와 내 코드(if문) 간의 차이는?

⇒ (GPT) 교재 코드는 센서 변화에 동기적으로 반응하며 busy waiting하므로 이벤트를 확실히 잡을 수 있지만 CPU를 계속 사용하게 되고,
내 코드는 한 지점에서 멈춰있지 않아서 다른 코드를 실행할 수 있지만 loop가 한 번 돌 때 순간 센서값을 확인하는게 전부이므로 이벤트를 놓칠 수 있음

실무에서는 `if + millis()`기반 타이머, 인터럽트를 사용함

</aside>
