# 스프링 부트

Spring Boot Up & Running 처음부터 제대로 배우는 스프링 부트(마크 헤클러/오시영, 서정대) p. 69~82

---

## 데이터베이스 액세스

### DB 의존성 추가

- 스프링 이니셜라이저에서 스프링 데이터 JPA 의존성 + DB드라이버 의존성 선택

> ❓“특정 '스프링 데이터'모듈에는 단일 의존성을 가진 DB드라이버가 포함되는데, 이는 '스프링 이니셜라이저'에서 선택하면 됩니다. 스프링이 'JPA-호환 데이터 스토어' 액세스를 위해 JPA를 사용하는 경우, 스플이 데이터 JPA 의존성과 사용하는 DB드라이버 의존성을 선택해야 합니다.”
-  이 문장의 의미가 뭐지? 스프링 데이터를 선택하거나, JPA의존성+DB드라이버 의존성을 선택하라는 말인가..

⇒ ‘스프링 데이터’모듈에는 `spring-data-jpa`(JPA(관계형DB)를 위한 모듈), `spring-data-mongodb`, `spring-data-redis` 등등 많은 하위 프로젝트가 있음(포함관계)

프로젝트에 데이터베이스를 적용하기 위해서는 `spring-data-jpa` + `mysql driver`처럼 JPA의존성과 DB드라이버 의존성을 선택하라는 의미


**H2**

- 인메모리 모드, 디스크 기반 모드가 있음
- `pom.xml`의 `<dependencies>` 에 의존성 추가 시 사용 가능
- 의존성 추가 시 `scope` 를 설정할 수 있음
    
    → `runtime`으로 설정하면 의존성이 런타임과 테스트 클래스 경로에 존재하지만 컴파일 경로에서는 빠짐
    

### DB관련 속가

**Entity**

- JPA 어노테이션 중 하나
- 클래스에 붙여서 DB테이블을 만들 수 있음
    
    ⇒ 저장, 조회할 수 있는 entity가 됨
    

**@Id**

- 속성에 붙여서 DB테이블의 ID필드로 만들 수 있음

**기본 생성자**

- JPA를 통해 DB를 사용하려면 전달되는 인자가 없는 기본 생성자가 필요함
- 기본 생성자를 사용하기 위해서는 모든 멤버 변수가 `final`이 아니어야 함(`mutable`)
- JPA가 id와 같은 속성에 값을 할당하려면 변경자 메서드(`mutator` / `setter`) 필요

## Repository

- DB에 접근하기 위한 방법 중 하나(추상화 인터페이스)
- `DB에 저장된 객체`, `객체의 ID와 primary key`의 플레이스홀더

**CrudRepository 사용**

- repository를 상속하는 인터페이스를 정의하여 사용할 수 있음

```java
interface CoffeeRepository extends CrudRepository<Coffee, String> {}
```

⇒ CrudRepository에 정의된 두 타입이 Repository의 플레이스홀더인 객체(Coffee)와 ID(String)

- 컨트롤러에 repository 객체를 주입(autowire) (멤버 변수 + 생성자)
    
    ⇒ 외부 API요청 들어오면 컨트롤러가 저장소에 접근 가능
    

**Repository를 사용하도록 Refactor**

- 기존 생성자에서 `ArrayList`에 데이터를 추가하던 것을 `Repository`에 추가하도록 변경할 수 있음
- CrudRepository의 내장함수
    - `repository.saveAll()` ( = `arrayList.addAll()`)
    - `findAll()` → Iterable 반환
    - `findById(String id)` → Optional 반환
    - `save()` ( = `arrayList.add()`)
    - `existById(String id)` → 새로운 데이터인지 기존에 존재하는지 확인. boolean 반환
    - `deleteById(String id)`

### 리팩토링

- 초기 데이터 생성 기능을 별도의 컴포넌트로 분리 (현재는 컨트롤러의 생성자에 있음)
    
    ⇒ 언제든지 활성화/비활성화 할 수 있음
    
- 애플리케이션 실행 시 자동으로 코드가 실행되도록 하는 방법
    1. `@PostConstruct`
        
        빈 생성 직후(의존성 주입 후) 한번만 실행
        
        빈 초기화, 내부 필드 준비, 내부 상태 설정 또는 확인을 위해 사용
        
        컴포넌트(빈 클래스) 내부 메서드로 작성
        
        람다 사용 불가능
        
    2. `CommandLineRunner` + `ApplicationRunner` 
        
        애플리케이션 시작(초기화) 후 실행
        
        애플리케이션 초기 실행 작업(DB초기화, 테스트 데이터 삽입, 외부 API 호출 등)을 위해 사용
        
        별도 클래스 혹은 람다로 작성
        

c.f) 스프링 빈의 초기화 순서

1. 객체 생성(`new`)
2. 의존성 주입(`@Autowired`, 생성자 주입 등)
3. `@PostConstruct` 실행
4. 애플리케이션 전체 실행 후 `CommandLineRunner` / `ApplicationRunner`실행
