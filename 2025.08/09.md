# 코딩 테스트

코딩 테스트 합격자 되기 C++편(박경래) p. 225~238

---

### 문제 14 | 표 편집 🐟

**시도한 풀이**

1. 문자열로 행의 인덱스의 ‘O’, ‘X’만 관리하기
    - `C` → 정답 문자열의 해당 인덱스를 ‘X’로 수정하고 인덱스 스택에 push
    - `U X`, `D X` → 횟수만큼 인덱스에 +, -
    - `Z` → 정답 문자열의 해당 인덱스를 ‘O’로 수정하고 스택에서 pop
    
    <aside>
    ❓
    
    `U X`, `D X`로 이동할 때 어떻게 죽은 행을 제외하고 이동할 수 있을까?
    
    1. 한칸씩 움직일 때마다 해당 행이 ‘O’인지, ‘X’인지 확인
    
    ⇒ 최악의 경우 행의 개수만큼 확인해야 함(O(MN); M: 행 개수, N: 명령어 개수)
    
    </aside>
    
2. linked list처럼 각 행마다 인접 행의 인덱스를  prev, next로 관리하기
    - 각 행이 죽었는지 살았는지 나타내는 문자열, 혹은 배열 필요
    - `C` → prev의 next를 현재의 next로, next의 prev를 현재의 prev로
        
              → 현재의 prev, next의 인덱스를 -1로 바꿔서 죽은 행을 나타낼 수도 있음
        
              → 죽은 행의 인덱스를 스택에 pus
        
    - `U X`, `D X` → 횟수만큼 반복문을 돌려서 prev/next로 이동
    - `Z` → 스택의 top의 prev, next를 수정하고 스택 pop
    
    <aside>
    ❓
    
    부활한 행의 인근 행이 모두 죽은 행일때 어떻게 살아있는 행의 인덱스를 얻을 수 있을까?
    
    1. 살아있는 행 까지 순회해서 찾기
    
    ⇒ 최악의 경우 O(MN); M: 행 개수, N: 명령어 개수, 이 문제는 최대 O(NlogN)의 알고리즘으로 풀어야 함
    
    1. 죽은 행의 prev, next도 관리
    
    ⇒ 역시 최악의 경우 행 전체를 봐야하므로 O(MN)
    
    </aside>
    

**결론**

- 내가 걱정했던 문제: 부활한 행의 prev, next도 죽어있으면 아무리 이전 행의 next인  `next[current[prev]]`를 수정해 봤자 현재 살아있는 행과는 이어지지 않는다는 것
    - 걱정하지 않아도 되는 문제였음..
    - 어차피 부활시키는 것이 모두 “가장 최근에 죽었던 행”이라서 최근에 죽은 행의 prev, next가 outdated될 일은 없음
    - 2→3→4행을 차례로 삭제하고 뜬금없이 3행을 부활시키면 위와 같은 문제가 발생할 수 있음. 그러나 문제에서 제시한 것은 언제나 가장 최근 행인 4행을 부활시키는 것이기 때문
- 따라서 1번 풀이는 죽은 행을 시간복잡도를 고려했을 때 적절하지 않고, 2번 풀이가 정답과 가까움

**개선**

- 가독성
    - prev, next를 관리할 때 행의 배열을 `vector<pair<int, int>>`로 선언해서 `first`, `second`로 접근했는데, 인덱스를 수정할 때 코드의 길이도 길어지고 가독성도 떨어짐
        
        ⇒ 저자의 풀이처럼 `up`, `down`배열을 따로 선언하는 것이 좋아보임
        
    
    ```cpp
    // 전
    vector<pair<int, int>> pointer;
    {...}
    	if (c == "Z") {
    		int restore = stk.top();
    		pointer[pointer[restore].first].second = restore;
    
    // 후
    vector<int> up;
    vector<int> down;
    {...}
    	if (c == "Z") {
    		int restore = stk.top();
    		down[up[restore]] = restore;
    ```
    
- 임시 공간
    - 표의 맨 뒤에서는 삭제했을 때 이전 행으로 이동함
        
        ⇒ 이를 위해 표 앞 뒤로 임시 공간을 설정
        

**`substr()`** 

- `substr(2)`  → 인덱스 2부터 끝까지 자르기
- `substr(2, 4)` → 인덱스 2부터 4 전까지 자르기

## 큐

- FIFO(First In First Out)
- 사용 예시
    - 작업 대기열: 네트워크 통신 시 서버는 클라이언트의 요청을 순서대로 큐에서 처리
    - 이벤트 처리: 사용자의 이벤트를 애플리케이션이나 시스템에서 큐를 통해 처리
