코딩 테스트 합격자 되기 C++편(박경록) p. 126~128(04장), 159~175(5장)

---

# 코딩 테스트 코드 구현 노하우

> **SUMMARY**
>구현 문제는 원래 코드가 길고 복잡할 수도 있다. 기능별로 함수를 잘 나누는 것이 좋다.
> 

## 조기 반환(early return)

- 가독성 상승, 깔끔한 예외 처리
- 함수 자체를 조기에 종료할 수 있으므로 예외 처리 하지 않아도 됨

**예시**

- `total`의 값이 100보다 큰 경우 `total`에 0.9를 곱하고 반환

```cpp
double total_price(int quantity, double price) {
	double total = quantity * price;
	if (total > 100) return total * 0.9;
	return total;
}
```

## 보호 구문(guard clauses)

- 로직 진행 전 예외 처리 코드 추가
- 입력값에 대한 예외를 사전에 처리할 수 있어 이후 동작 구현에 집중할 수 있음

**예시**

- 벡터가 비었거나, N이 0인 경우를 사전에 예외 처리

```cpp
// 벡터에 있는 값을 모두 더해서 N으로 나눈 값을 반환하는 함수
double get_avg(const vector<int>& arr, int N) {
	if (arr.empty()) return -1;
	if (N == 0) return -1;
	
```

# 배열 문제풀이

### 문제 06 | 실패율

```cpp
의사 코드
1. stages 정렬
2. 스테이지 하나에 대해 시작 인덱스, 끝 인덱스 
3. 실패율 = (끝 인덱스 - 시작 인덱스) / 전체
4. 실패율 배열에 저장, 전부 계산 후 정렬
```

- 처음에 의사 코드를 위와 같이 작성했는데, 인덱스 얘기가 들어가는 순간 동작이 아닌 구현에 관한 내용이 되기 때문에 잘못됨

```cpp
의사 코드
1. stages 정렬
2. 각 스테이지마다 있는 사용자 수 구하기
3. 실패율 구하기 (현 스테이지에 있는 유저 수 / 현 스테이지보다 위에 있는 유저 수)
4. 실패율 저장, 정렬
```

- 위와 같이 작성하면 동작에 대해서만 나타난 의사 코드가 됨
- 현 스테이지에 있는 유저 수를 따로 저장할 생각을 못해서 코드를 복잡하게 짰는데, 따로 저장하는 것이 훨씬 효율이 좋아보임

<aside>


>❓ 실패율 저장하여 정렬하는 작업을 어떤 자료구조에서 수행하면 좋을지? 배열이나 set은 정렬해 버리면 순서 정보(인덱스)가 사라짐..
>
>⇒ pair<int, float> 에서 first는 stage 넘버, second는 실패율
     이후 sort함수로 second를 기준으로 내림차순 정렬하되 동일하면 first로 오름차순

</aside>

**누적합**

- 어떤 배열을 기반으로 요소들의 누적된 합을 저장해 새로운 배열 생성

(추후 추가 예정..)

### 문제 07 | 방문 길이

- 구현 문제는 별다른 알고리즘이 필요하지 않을 수 있음
- 구현 문제는 답안 코드가 긴 경우가 많으므로 기능별로 함수를 구현하는 것이 좋음
- 시간이 너무 오래 걸린다…

---

# 스프링 부트

Spring Boot Up & Running 처음부터 제대로 배우는 스프링 부트(마크 헤클러/오시영, 서정대) p.47~54(3장)

---

> **SUMMARY**
>
`@RestController` 를 통해 컨트롤러 객체를 만들 수 있고, `@RequestMapping` 을 통해 요청을 수신하는 API객체를 만들 수 있다. 
`@RequestMapping`을 각 메서드마다 추가하는 대신 클래스에 붙여 공통 URI를 관리하고, 각 메서드의 역할에 따라 `@GetMapping`, `@PostMapping`등의 어노테이션을 통해 세부 URI 및 동작을 관리할 수 있다.
`@PathVariable`, `@RequestBody` 를 메서드의 인자에 붙여 함수 내에서 활용할 수 있다.
`HttpStatus` 를 통해 응답 시 상태 코드를 전달할 수 있다.
> 

## GET

**RestController**

```cpp
@RestController
class RestApiDemoController {
	private List<Coffee> coffees = new ArrayList<>();
}
```

- 여러 Coffee객체를 반환하는 메서드를 지원하기 위해 Coffee 객체 목록을 만듦
- 좌변의 Coffee 타입으로 우변의 비어있는 ArrayList의 타입을 자동 추론함(`<Coffee> → <>`)

**의존성 주입**

- 의존성(Dependency): 어떤 객체가 다른 객체를 필요로 하는 것
- 주입(Injection): 그 필요한 객체를 외부에서 넣어주는 것
- 예시: 레스토랑 클래스에서 요리사가 필요할 때
    
    ```java
    public class Restaurant {
    	private Chef chef = new Chef(); // 직접 만듦
    }
    	
    ```
    
    - `Restaurant`클래스가 스스로 `Chef`를 만듦
        
        ⇒ 나중에 `Chef`를 바꾸고 싶을 때는 `Restaurant`도 고쳐야 함 → 유연성 ↓
        
    
    ```java
    public class Restaurant {
    	private final Chef chef;
    	
    	// 생성자에서 외부로부터 chef를 주입받음
    	public Restaurant(Chef chef) {
    		this.chef = chef;
    	}
    }
    ```
    
    - `Restaurant`는 `Chef`가 필요하다는 것만 알고, 직접 만들지 않음
    - 외부에서 적절한 `Chef`를 받음
    - 유연성, 테스트 용이성, 유지보수성 ↑

**컨트롤러에도 생성자가 필요한 이유**

- 의존성 주입(DI: Dependency Injection) 때문
- 컨트롤러가 연결되는 서비스 계층의 객체를 생성자를 통해 외부에서 전달받을 수 있음
- 교재 예시에서는 컨트롤러 객체 생성 시 데이터를 추가하는 코드 사용
    
    ```java
    public RestApiDemoController() {
    	coffees.addAll(List.of(
    		new Coffee("Cafe Cereza"),
    		new Coffee("Cafe Ganador"),
    		new Coffee("Cafe Lareno"),
    		new Coffee("Cafe Tres Pontas")
    	));
    }
    ```
    

**@RequestMapping**

```java
@RequestMapping(value = "/coffees", method = RequestMethod.GET)
Iterable<Coffee> getCoffees() {
	return coffees;
}
```

- `/coffees`경로로 들어온 API 요청에 멤버 변수인 `coffee` 를 반환하는 메서드
- `Iterable<T>`는 반복할 수 있는 컬렉션 타입
    
    ex) `List<Coffee>`, `Set<Coffee>`
    
- `List`는 `Iterable`을 상속하고 있음

**매핑 어노테이션**

- 위의 코드에서`@RequestMapping` 대신 `@GetMapping`을 사용하면 코드가 더 간결해짐

```java
@GetMapping("/coffees")
Iterable<Coffee> getCoffees() {
	return coffees;
}
```

- 마찬가지로 `@PostMapping`, `@PutMapping`, `@DeleteMapping`도 사용 가능
- `@RequestMapping`대신 `@GetMapping`을 사용하려면 `RestApiDemoController`클래스에 `@RequestMapping("/")`어노테이션을 추가해야 함

**@PathVariable**

- `id`에 따라 단일 아이템을 조회하고 싶은 경우

```java
@GetMapping("/coffees/{id}")
Optional<Coffee> getCoffeeById(@PathVariable String id) {
	for (Coffee c: coffees) {
		if (c.getId().equals(id)) {
			return Optional.of(c);
		}
	}
	return Optional.empty();
}
```

- 경로의 `{id}` 는 URI 변수 → `@PathVariable` 어노테이션이 달린 id 매개변수를 통해 `getCoffeeById`메서드에 전달됨

## Post

- `POST`는 리소스의 세부 정보(일반적으로 JSON) 제공
- 해당 서비스에 POST 요청을 해서 지정된 URI에 리소스 생성

```java
@PostMapping("/coffees")
Coffee postCoffee(@RequestBody Coffee coffee) {
	coffees.add(coffee);
	return coffee;
}
```

- 스프링 부트 Jackson  라이브러리의 자동 마샬링 →  커피 정보를 Coffee객체로 받을 수 있음

## PUT

- 기존에 만든 리소스가 있으면 업데이트, 없으면 생성해야 함

```java
@PutMapping("/coffees/{id}")
Coffee putCoffee(@PathVariable String id, @RequestBody Coffee coffee) {
	int coffeeIndex = -1;
	
	for (Coffee coffee c: coffees) {
		if (c.getId().equals(id)) {
			coffeeIndex = coffees.indexOf(c);
			coffees.set(coffeeIndex, coffee);
			}
		}
		
		return (coffeeIndex == -1) ? postCoffee(coffee) : coffee;
```

## Delete

**`removeIf`**

- Predicate값을 받음
- Predicate: 목록에 id가 일치하는 항목이 존재하면 `true`를 반환하는 람다 함수

```java
@DeleteMapping("/coffees/{id}")
void deleteCoffee(@PathVariable String id) {
	coffees.removeif(c -> c.getId().equals(id));
}
```

## 리팩토링

- `/coffees`가 모든 메서드의 URI에 존재하므로 이를 클래스 수준인 `@RequestMapping`어노테이션에 작성
    
    ⇒ 하위 경로가 존재하지 않으면 작성하지 않아도 됨(get, post의 경우)
    

## 상태 코드

- `GET`: 상태 코드 X
- `POST` , `DELETE`: 상태 코드 사용 권장
- `PUT`: 상태 코드 필수

```java
@PutMapping("/{id}")
ResponseEntity<Coffee> putCoffee(@PathVariable String id, @RequestBody Coffee coffee) {
	int coffeeIndex = -1;
	
	for (Coffee c: coffees) {
		if (c.getId().equals(id)) {
			coffeeIndex = coffees.indexOf(c);
			coffees.set(coffeeIndex, coffee);
			}
		}
		return (coffeeIndex = -1) ?
						new ResponseEntity<>(postCoffee(coffee), HttpStatus.CREATED) :
						new ResponseEntity<>(coffee, HttpStatus.OK);
```

- Coffee 객체 + Http 상태 코드 포함된 `ResponseEntity`를 반환하도록 수정된 코드
    - 저장소에 해당 커피가 존재하는 경우 → `201(CREATED)`
    - 존재하지 않는 경우 → `200(OK)`
