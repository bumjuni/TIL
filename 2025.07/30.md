# 코딩테스트(C++)

코딩테스트 합격자 되기 C++편(박경록) p. 133~158(05.배열)

---

> **SUMMARY**
>
배열은 데이터의 수정이 없을 때 선택해야 효율적이다
문제를 읽고 바로 코드로 넘어가지 말고, 반드시 제약조건 분석을 통해 시간복잡도와 의사 코드를 생각해야 한다
`unique()`, `erase()` , `assign()`, `max_element()`를 활용할 수 있다
`size()`는 컨테이너 요소 개수를 알고싶을 때, `sizeof()`는 객체에 할당된 메모리 크기를 알고싶을 때 사용한다
> 

## 배열

**배열 연산의 시간 복잡도**

- 접근: 모든 위치에 대해 임의 접근이므로 O(1)
- 삽입: 삽입 위치에 따라 나머지 데이터를 밀어야 하므로 최악의 경우 O(N)

**배열 선택 시 고려할 점**

- 할당할 수 있는 메모리 크기 확인
    
    ⇒ 1차원 배열은 1000만 개, 2차원은 3000*3000
    
- 데이터 삽입이 많은지 확인
    
    ⇒ 데이터에 자주 접근하거나 읽을 때는 성능이 좋지만 선형 자료구조이기 때문에 데이터 삽입이 많으면 시간 복잡도가 높아져 시간 초과 발생
    

## 배열 문제풀이

### **문제 01 | 배열 제어하기1**

- 문제 읽고 바로 코딩부터 하려고 하지 말고
    1. 입력 개수 확인하고 시간복잡도 추산하기
    2. 제약 조건 확인하고 테스트케이스 추가하기
    3. 의사 코드, 또는 어떻게 구현할 지 생각해보기
- `algorithm`헤더의 `sort()`의 시간복잡도 = $O(NlogN)$

<aside>


** ❓ C++ 문법**

```cpp
copy(arr.begin(), arr.end(), std::ostream_iterator<int>(cout, " "));
```

- 전체 배열(벡터)을 출력하기 위해 사용
- 아래와 같이 범위형 반복문을 사용하여 작성할 수도 있음

```cpp
for (const auto& it : arr) cout << it << " ";
```

</aside>

  
<aside>

**❓벡터 초기화**

`vector<int> vec2 = vec1;` 과 같이 쓰면 값이 복사? 혹은 주소가 복사?

</aside>

### **문제 02 | 배열 제어하기2**

- `unique()`
    - `algorithm` 헤더
    - 벡터의 앞에서부터 중복된 값들을 제거한 원소를 채워넣음 ⇒ 뒷부분에는 중복된 원소 남아있음
    - 시간복잡도 `O(N)`
    - 반환값: 중복 제거된 원소 다음 값을 가리키는 iterator
        
        ⇒ `erase()`를 사용하여 중복 제거된 값을 삭제할 수 있음
        
        `v.erase(unique(v.begin(), v.end()), v.end());`
        

<aside>

> [!NOTE]
> ⭐ `unique()` 는 중복 원소가 연속해서 나올 때만 제거할 수 있다. 따라서 함수 적용 전 정렬 필수

</aside>

- `erase()`
    - 입력값으로 주어진 iterator, 또는 iterator간 범위 내의 벡터 원소를 삭제
    - ex) 5번째 원소 삭제: `v.erase(v.begin() + 5);`
- `sort()`의 `compare` 함수
    - 오름차순 일 때는 `return a < b`
내림차순 일 때는 `return a > b`
크레센도를 기억하면 좋다

  
  <details>
  <summary> 참고 </summary>
    
    <li> https://sangwoo0727.github.io/c++/Cplus-unique/ </li>
    
    <li>    https://cho001.tistory.com/164 </li>
<li>    https://velog.io/@whipbaek/sort-%EC%99%80-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A7%80%EC%A0%95-compare-%ED%95%A8%EC%88%98 </li>
  </details>

### **문제 03 | 두 수를 뽑아서 더하기**

- `std::set`은 자동 오름차순 정렬, 중복 제거
    - 레드블랙 트리로 구현되어 있음
        
        ⇒ 이중 반복문을 통해 값 $n^2$개 삽입 시 시간복잡도 $O(n^2log(n))$
        

### 문제 04 | 모의고사 🐟

<aside>

> **⭐ 모듈러 연산(%)은 나눗셈과 다르게 0에서도 가능**
> 
> ex) 0 % 3 = 3
>   				0 / 3 = (Error)

</aside>

<aside>

  
> **⭐ `sizeof()`와  `v.size()`의 차이 (+ `str.length()`)**
> 
- `sizeof()`
    - 변수, 자료형 등의 메모리 크기를 std::size_t 타입으로 반환
- `size()`
    - 벡터, 문자열 등의 컨테이너의 요소 수를 size_type 타입으로 반환
- `length()`
    - `string` 헤더에 존재하며, 문자열의 길이를 size_type 타입으로 반환
<details>
  <summary>
  참고
  </summary>
    https://jangwoojun.github.io/posts/C++-size,-length,-sizeof-%ED%95%A8%EC%88%98%EB%93%A4%EC%9D%80-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%BC%EA%B9%8C/
  </details>
</aside>

- `max_element`
    - `algorithm` 헤더에 존재
    - 정렬 없이 최댓값을 구할 수 있음
    - iterator를 반환
    - 컨테이너의 최댓값: `*max_element(start, end)`
    - 컨테이너의 최댓값의 주소: `max_element(start, end)`
    - 컨테이너의 최솟값: `*min_element(start, end)`
    - 컨테이너의 최솟값의 주소: `min_element(start, end)`

  <details>
  <summary>참고
    </summary>
    https://atomic0x90.github.io/c++/2021/07/31/c++-max-element-min-element.html
  </details>
    

### 문제 05 | 행렬의 곱셈

- `assign()` : 벡터 공간 할당
    - 이전 벡터 원소는 모두 삭제하고, 새로운 내용 할당
    - `assign(InputIterator first, InputIterator last)` : iterator가 가지는 내용을 first부터 last까지 벡터에 집어넣음
    - `assign(size_type n, const T& u)` : T 타입 원소 u를 n개 집어넣음
    
    ```cpp
    // arr1의 원소 개수만큼 int형 벡터를 집어넣음
    // int형 벡터는 arr2[1]의 원소 개수만큼 0을 집어넣은 것
    // 크기가 [arr1의 행, arr2의 열] 인 벡터
    vec.assign(arr1.size(), vector<int>(arr2[1].size, 0));
    
    // 100을 7번 집어넣음
    vec.assign(7, 100); 
    
    // 기존 벡터 v의 처음과 끝을 제외한 원소들을 집어넣음
    it = v.begin() + 1;
    vec.assign(it, v.end() - 1);
    ```
    
<details>
  <summary>
  참고
  </summary>
    
    https://modoocode.com/183
  </details>

# 스프링 부트

Spring Boot Up & Running 처음부터 제대로 배우는 스프링 부트(마크 헤클러/오시영, 서정대) p.47~54(3장)

---

> **SUMMARY**
> 
> REST란 곧 stateless, API는 다른 코드를 이용하기 위한 인터페이스이다
따라서 REST API는 GET, POST, PUT, DELETE 등 요청에 현재 상태를 포함하여 다른 코드를 이용하기 위한 인터페이스를 포함하는 HTTP 메서드를 말한다
MVC는 관심사를 분리하여 데이터, 데이터의 표현, 데이터의 제어 및 전송을 관리하는 디자인 패턴이다
`@Controller` 어노테이션을 통해 클래스가 컨트롤러 역할을 하도록 만들 수 있고, 
`@ResponseBody` 어노테이션을 통해 메서드의 반환값이 곧 웹의 response body가 되도록 만들 수 있다
`@RestController`어노테이션을 통해 위의 두 기능을 하는 REST API를 만들 수 있다
> 

## REST API

**monolithic 애플리케이션이 유효한 경우**

- 기능이 긴밀하게 결합되어 있고, 유연함보다 성능이 더 중요할 때
- 도메인 간 경계가 모호할 때
- 관련된 모든 기능의 애플리케이션 확장 요구사항(scaling requirements)이 알려져 있고 일관적일 때
- 기능 변화가 없거나 매우 느리거나, 변화 범위가 제한적일 때

<aside>


> ❓ “도메인 간 경계가 모호”가 무슨 말인지?
- 확장 요구사항과 monolithic application이 무슨 관계인지? 마이크로 아키텍쳐는 확장성이 뛰어난 데 반해 모놀리식은 그렇지 않은 게 일반적이므로 확장성에 필요한 사항이 잘 알려져 있거나 일관적일 때 확장성을 위해 MSA를 선택하지 않아도 된다는 의미?
</aside>

**REST**

- Represntational State Transfer
- stateless한 성질
    
    ⇒ 상호작용하는 다른 서비스가 자기 서비스의 ‘현재 상태’를 저장하리라 기대하지 않고
    
    매번 요청할 때마다 관련 상태의 표현(representation)을 제공
    
- 생존가능성(survivability)과 회복탄력성(resilence) 향상

**API**

- Application Programming Interface
- 개발자가 작성한 사양/인터페이스
- API를 통해 라이브러리, 다른 애플리케이션, 서비스 같은 다른 코드를 사용할 수 있음

**REST API 종류**

- HTTP 메서드 중 일부만 사용됨
- POST, GET, PUT/PATCH, DELETE
    - 주로 사용되는 그룹
    - 리소스에 수행하는 일반적인 작업
- OPTIONS, HEAD
    - 요청/응답의 통신에서 가능한 옵션 및 헤더 조회

### **REST API를 구현하는 간단한 마이크로서비스 생성하기(실습)**

**Spring Web**

- initializr dependency
- RESTful을 포함한 웹, 스프링 MVC를 사용한 애플리케이션 만들기

**도메인 생성**

- 관리할 리소스를 표현하기 위해 도메인 클래스가 필요

```cpp
class Coffee {
	private final String id;
	private String name;
	
	public Coffee(String id, String name) {
		this.id = id;
		this.name = name;
	}
	
	public Coffee(String name) {
		this(UUID.randomUUID().toString(), name);
	
	public String getId() { return id; }
	public String getName() { return name; }
	public void setName(String name) { 
		this.name = name; 
	}
```

- id 필드
    - final로 선언해 할당 후 수정 불가
    - 접근자(accessor/getter method) → 없음
    - 변경자(mutator/setter method) → getId
    - 생성 시 id를 입력하지 않으면 고유 식별자인 id값을 기본 제공(randomUUID)
- name 필드
    - final로 선언하지 않았으므로 추후 변경 가능
    - 접근자 → getName
    - 변경자 → setName

### MVC

- 사용자 인터페이스(V), 데이터(M) 및 논리 제어(C)를 구현하는데 사용되는 디자인 패턴
- 관심사를 분리하여 업무 분리 가능, 관리 용이

![image.png](attachment:fb9916a1-f058-4a3b-84b6-84b5272d3f61:image.png)

- Model
    - 데이터와 비즈니스 로직 관리
    - 앱이 포함해야 할 데이터 정의(상품명, 가격, 수량 등)
    - DB에서 데이터를 가져오고, 처리하고, 저장
    - 데이터 상태 변경 시 뷰에게 알리거나(쇼핑카트에 담기), 컨트롤러에게 알림(정렬 기준 변경)
- View
    - 레이아웃과 화면 처리
    - 표시할 데이터를 모델로부터 받음
- Controller
    - 모델과 뷰로 명령 전달, 업데이트 로직
    - 모델과 뷰는 다른 요소에 대해 알면 안되지만, 컨트롤러는 모델과 뷰에 대해 모두 알고 있어야 함
    - 사용자 입력(쇼핑 카트에 항목 추가, 제거)을 전송받아 모델을 적당히 처리(실제 데이터 변경)하고, 업데이트된 데이터를 뷰로 전송

  <details>
    <summary>
      
  참고
    </summary>
    <li>https://velog.io/@langoustine/%EC%97%AC%EA%B8%B0%EB%8F%84-MVC-%EC%A0%80%EA%B8%B0%EB%8F%84-MVC-MVC-%ED%8C%A8%ED%84%B4%EC%9D%B4-%EB%AD%90%EC%95%BC </li>
    
    <li>   https://developer.mozilla.org/ko/docs/Glossary/MVC </li>
  </details>

### Annotation

**`@Controller`**

- 스프링 MVC는 View가 서버 렌더링된 웹페이지로 제공된다는 가정 하에
    
    데이터(Model), 데이터를 전송하는 부분(Controller), 데이터를 표현하는 부분(View)을 분리해 생성
    
- MVC의 여러 부분을 연결하는데 `@Controller` 어노테이션이 도움
- `@Controller` 가 붙은 클래스는 `Model` 객체를 받음
- `ViewResolver`와 함께 작동해 애플리케이션 렌더링

**`@ResponseBody`**

- 클래스나 메서드에 추가해서 Controller 클래스가 JSON, XML 등 형식화된 응답을 반환하도록 할 수 있음
    
    ⇒ 메서드의 객체 또는 Iterable 반환값이 웹 응답의 전체 body가 됨
    
    ⇒ 모델의 일부로 반환되지 않음
    

<aside>


> ❓ Controller클래스에 `@ResponseBody`를 붙이면 모델의 일부로 반환되지 않는다는게 무슨 말이지..

</aside>

**`@RestController`**

- `@Controller`와 `@ResponseBody`를 하나의 어노테이션으로 합친 것
- 클래스에 `@RestController`를 달아서 REST API를 만들 수 있음
