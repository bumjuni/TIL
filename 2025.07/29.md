# 스프링 부트

Spring Boot Up & Running 처음부터 제대로 배우는 스프링 부트(마크 헤클러/오시영, 서정대) p.19~46(1장, 2장)

---

> **SUMMARY**

> 스프링 부트는 의존성 관리 최소화, 배포 간소화, 자동 설정을 통해 개발자에게 코드에 집중할 수 있는 환경을 제공한다.
>  
> 스프링 부트 프로젝트에는 여러 도구 옵션이 있는데 빌드 도구(Maven, Gradle), 언어(Java, Kotlin), 이니셜라이저(spring initializr, spring boot CLI), IDE 등을 선택할 수 있다.
> 

### 이해 안가는 개념	
  > 일반적으로 애플리케이션에서 제공하는 모든 기능에는 여러 기본 의존성이 필요합니다. 예를 들어 RESTful Web API를 개발하는 경우에는 HTTP  엔드포인트를 만들어 요청을 수신하고, 요청을 처리할 메서드/함수에 해당 엔드포인트를 연결한 후에 적절한 응답을 만들어 반환합니다. (p.19)
- RESTful Web API는 서버의 자원을 uri로 관리하며 GET, POST, PUT, DELETE의 네가지 요청으로 이루어진 API 정도로 이해를 하고 있음
- HTTP 엔드포인트를 만들어 요청을 수신한다는 말이 한번에 와닿지 않음
- HTTP 엔드포인트는 클라이언트로부터 요청을 수신하는 서버 자체로 이해하고 있었는데, ‘요청을 처리할 메서드/함수에 엔드포인트를 연결’한다고 하니까 네트워크 상에서는 처리기와 수신기를 구분하는건지 헷갈림
- HTTP가 한줄로 무슨 동작을 하는지, 네트워크 상에서 어떤 구조를 갖는지 공부해야겠음
    
> 마샬링(marshalling): 객체의 메모리 표현 방식을 저장이나 전송에 알맞은 데이터 형식으로 변환하는 프로세스입니다. 데이터를 서로 다른 컴퓨터 프로그램 간 혹은 같은 프로그램의 다른 부분에 옮길 때 사용합니다. 언마샬링(unmarshalling)은 마샬링의 반대로 직렬화(serialization)와 유사하거나 동일합니다.
- 처음에는 빅 엔디안-리틀 엔디안 변환인가? 했는데 아닌것 같음
- 본문 맥락이 ‘요청된 포맷의 객체를 마샬링/언마샬링하는 코드’인 걸로 봐서 JSON형식으로 변환하거나, parsing하는 코드인 것 같음
    
> DSL(Domain Specific Language), 도메인 특화 언어
- 그레이들(Gradle)은 DSL이라고 한다..

### 스프링 부트의 장점

1. 의존성 관리 최소화: BOM이라는 의존성을 중앙에서 관리해주는 POM을 통해 모든 의존성이 서로 완벽히 동작하도록 검증된 환경을 제공
2. 배포 간소화: 복잡한 여러 개의 jar파일을 다룰 필요 없이, 하나의 jar파일, 또는 즉시 실행되는 파일을 결과물로 제공하여 배포 과정을 단축함
3. 자동 설정: 데이터베이스 연결, 어플리케이션 종료 시 데이터베이스 자동 종료, 기본 호스트, 포트 등의 설정을 자동으로 제공하여 개발자가 로직 개발에 집중할 수 있는 환경 제공(설정보다 관습; convention over configuration)

## 도구 선택

### 빌드 도구

**메이븐(Maven)**

- 규칙이 엄격함 (프로젝트 구조) ⇒ 모든 환경이 정해져 있으므로 그것을 따르고, 코드에만 집중할 수 있음
- 선언형 접근 → `pom.xml`에 의존성과 플러그인 작성

**그레이들(Gradle)**

- 유연함
- 스크립팅 중심 ⇒ JDK버전 새로 출시되었을 때 일시적으로 gradle 업데이트가 되어있지 않아 문제 발생
- 변경사항이 없는 경우 컴파일X
- 큰 프로젝트의 경우 메이븐보다 빌드 속도 빠름(마이크로 아키텍처에서는 비슷함)

### 언어

- Java와 Kotlin 중 선택할 수 있는데, 둘다 자바 바이트코드로 변경되어 실행되므로 한 프로젝트 내에서 두 언어를 상황에 따라 모두 사용할 수도 있음
- 요즘에는 Java로 쓰여진 스프링부트 공식 문서에 Kotlin버전도 의무적으로 추가하고 있음

### Java 버전 관리

- SDKMAN!으로 쉽게 여러 JDK 버전을 설치하고, 업데이트할 수 있음
- 스프링 부트 CLI 및 그 외 도구 설치도 지원
- bash환경에서 작동하므로 윈도우의 경우 WSL+MINGW, 또는 git bash에서 설치할 수 있음
- https://sdkman.io/install/

### 스프링 이니셜라이저

- https://start.spring.io

### 스프링 부트 어플리케이션

- 자바 어플리케이션 실행 시 기본 메서드인 `public static void main()`
- 최상위 어노테이션 `@SpringBootApplication`, 메서드 내부에서 스프링 어플리케이션 실행 `SpringApplication.run()`

```java
@SpringBootApplication
public class DemoApplication {
	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args)
	}
```

---

# 코딩테스트(C++)

코딩테스트 합격자 되기 C++편(박경록) p.41~94

---

> **SUMMARY**
> 
입력 값에 따라 시간 복잡도를 고려하여 적절한 알고리즘을 선택해야 한다.
C++ 문법 중 명시적 형변환은 `static_cast<type>(var)` 과 같이 사용한다.
반복문과 함수 인자 전달 시 C++의 기본 속성인 `call by value`에 따라 컨테이너 전체를 복사하여 전달하면 복사 비용이 발생하므로 `레퍼런스`를 잘 활용하여야 한다. (수정할 때는 `레퍼런스`, 읽기만 할 때는 `상수 레퍼런스`)
`auto`, `범위 기반 반복문`, `반복자` 등을 활용하여 반복문을 작성할 수 있다.
> 

### 시간복잡도

- Big O notaion
    - 특정 x시점 이후부터 항상 $f(x) \le C * g(x)$ 를 만족
    - $C$는 상수
    - 위 두 조건을 만족하는 $C$가 있으면 $f(x)$의 최악의 시간 복잡도는 `O(g(x))`
- $x! > 2^x > x^2 > xlogx > x > logx > 1$
- 컴퓨터의 초당 최대 연산 횟수를 1억으로 상정
    
    
    | 시간복잡도 | 최대 연산 횟수 |
    | --- | --- |
    | $O(N!)$ | 10 |
    | $O(2^N)$ | 20~25 |
    | $O(N^3)$ | 200~300 |
    | $O(N^2)$ | 3000~5000 |
    | $O(NlogN)$ | 100만 |
    | $O(N)$ | 1000~2000만 |
    | $O(1)$ | 10억 |

### C++ 기본 문법

**부동소수형**

```cpp
double d = 2.5;
float f = 1.5f; // float는 끝에 f 붙이기

cout << sizeof(d) << endl; // double형 데이터 크기(Byte) = 8
cout << sizeof(f) << endl; // float형 데이터 크기(Byte) = 4
```

**형변환**

```cpp
int i = 65;
float f = 5.2f;

// 암시적 형변환: int -> float (메모리 더 큰 쪽으로)
double d = i + f;
cout << d << endl; // 70.2

// 명시적 형 변환: double -> int
cout << static_cast<int>(d) << endl; // 70
// 명시적 형 변환: int -> char
cout << static_cast<char>(d) << endl; // 'A'
```

**문자열 선언**

- `string` 표준 헤더 추가

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() { 
	string str1; // 빈 문자열 선언
	string str2 = "Hello, world" // 문자열 직접 초기화
	string str3(str2); // 문자열 복사
	string str4(str2, 0, 5); // 문자열 부분 복사 초기화 -> "Hello"
	string str5(10, '*'); // 반복된 문자로 문자열 초기화
	
	return 0;
}
```

**문자열 찾기** 

- `find()`
    - `<algorithm>` 헤더에 있는 것과 다름(`str.find()`는 문자열에서만 됨)
    - `O(N)`으로 동작
- `size_t` 타입: 컨테이너나 문자열의 크기 및 인덱스 표현

```cpp
string str = "Hello, C++ World!";
size_t pos1 = str.find('C'); // 7

size_t start_index = 2;
size_t pos2 = str.find("Hello", start_index); // (임의의 값 -> string::npos)
```

**문자열 추가, 수정**

```cpp
string str = "APPLE";

str += ", World!"; // "APPLE, World!"
str.replace(7, 4, "Col"); // "Apple, Cold!"
```

### STL

**레퍼런스**

- C++은 기본적으로 `call by value`
    - 호출한 함수의 메모리 공간과 호출된 함수의 메모리 공간이 다름
    - 함수의 인자로 전달된 변수 값을 함수 내에서 수정 시 원래 변수 값 변경되지 않음
    - 함수의 인자로 크기가 큰 컨테이너 전달 시 복사 비용 발생
        
        ⇒ `call by reference` 문법 (참조자 `&`) 사용
        
        ⇒ 참조자를 통해 메모리에 직접 접근 가능
        
- 참조값 전달이 아닌 포인터 문법을 통한 주소값 전달도 동일한 효과(call by reference)

```cpp
void modify(int& value) {
	value = 10;
}

int main() {
	int value = 5;
	modify(value);
	cout << value << endl; // 10
}
```

**auto**

- 변수 타입 자동 추론

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
	auto num = 42; // int로 추론
	auto pi = 3.141592 // doucle로 추론
	auto str = "hello!" // string으로 추론
}
```

**범위 기반 반복문**

- `for (타입 변수명 : 컨테이너) { }`
- 배열이나 컨테이너의 모든 원소 순회

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <set>

using namespace std;

int main() {
	// vector 예시
	vector<int> vec = {1, 2, 3, 4, 5};
	for (int num : vec) {
		cout << num << " ";
	}
	cout << endl;
	// 1, 2, 3, 4, 5
	
	// map 예시
	map<string, int> fruitMap = {{"apple", 1}, {"banana", 2}, {"cherry", 3}};
	for (const auto& pair : fruitMap) {
		cout << pair.first << " = " << pair.second << " ";
	}
	cout << endl;
	// apple = 1 banana = 2 cherry = 3
	
	// set 예시
	set<string> fruitSet = {"apple", "banana", "cherry"};
	for (const auto& fruit : fruitSet) {
		cout << fruit << " ";
	}
	cout << endl;
	// apple banana cherry
	
	return 0;
}
```

- 값을 수정할 필요가 없으므로 상수 레퍼런스 적용하여 `const auto&` 사용
- 컨테이너를 반복문에서 사용하거나 함수의 인자로 전달할 때에는 반드시 복사 비용 고려해야 함
- 수정해야 할 때는 레퍼런스(`&`), 수정이 필요 없을 때는 상수 레퍼런스(`const <type>&`) 적용
- vector 예제에서는 const reference 사용되지 않았고, 나머지에서는 사용됨
    - vector의 요소 하나씩 복사되어 `num` 에 저장되고, 반복문 실행
    - `int`의 경우 크기가 작아서 const reference 사용하지 않아도 됨

**반복자**

- 컨테이너 종류와 관계없이 동일한 코드로 원소 순회 가능
    
    ⇒ 유지보수와 재사용성
    
- `find()` : 해당 원소를 찾으면 위치를 반환, 못 찾으면 `end()` 반환

**순방향 반복자**

- `begin()`: 컨테이너의 첫 원소 위치
- `end()`: 컨테이너의 마지막 원소 위치 다음

```cpp
#include <algorithm> // find()를 위한 헤더
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int main() {
	// vector 예시: 순회
	vector<int> vec = {1, 2, 3, 4, 5};
	
	for (auto it = vec.begin(); it != vec.end(); ++it) {
		cout << *it << " ";
	}
	cout << endl;
	// 1 2 3 4 5
	
	// vector 예시: 탐색
	auto result = find(vec.begin(), vec.end(), 3);
	if (result != vec.end()) {
		cout << "Found: " << *result << endl; // find는 반복자 반환
	} 
	else {
		cout << "Not Found" << endl;
	}
	// Found: 3
	
	// ------------------------------------------------------------
	
	map<string, int> myMap = {{"apple", 1}, {"banana", 2}, {"cherry", 3}};
	
	// map 예시: 순회
	for (auto it = myMap.begin(); it != myMap.end(); ++it) {
		cout << it->first << ": " << it->second << endl;
	}
	/*
		apple: 1
		banana: 2
		cherry: 3
	*/
	
	// map 예시: 탐색
	auto result = find("banana");
	if (result != myMap.end()) {
		cout << "Found: " << result->first << "->" << result->second;
	}
	else {
		cout << "Not Found";
	}
	// Found: banana->2
	
	return 0;
}
```

**역방향 반복자**

- 컨테이너의 끝에서 시작으로 이동
- `++` 연산자 사용 시 이전 원소로 이동
- `rbegin()`: 컨테이너의 맨 마지막 원소
- `rend()`: 컨테이너의 맨 처음 원소의 직전 위치

```cpp
vector<int> vec = {1, 2, 3, 4, 5};

for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
	cout << *it << " ";
}
cout << endl;
// 5 4 3 2 1
```
